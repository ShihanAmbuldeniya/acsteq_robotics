# Line Following Robot

#### Description:
 This robot is programed to follow black lines in a white color background using a algorithm that I've developed. The robot is calibrated before the trial runs on the platform. The line follower detects and follows the black line using an algorithm called **PID** (PID stands for Proportional-Integral-Derivative controller)
 #### PID Algorithm
 If the position is higher or lower than 3500, then the robot must turn left or right. But if we put this in a loop, the robot will oscillate until it eventually gets off track. Using the PID algorithm the robot will no longer oscillate and will be able to take different types of curves at different curve radius without getting off the line. To make it easier to understand the program, we will use an integral called error. It can be both positive and negative. (You can observe the PID algorithm that I developed, in the folder motion_control_ino -->  under the function "void propotional()") The three control terms proportional (Kp), integral (Ki) and derivative (Kd) must be adjusted so that the robot can follow a line without oscillating or slowing down or getting off the track. (after hundreds of test runs and randomly applying different values for each control term I was able conclude the final accurate values for Kp, Ki and Kd) The proportional term is the error in here, It directly controls how to take the curves - if Kp is a small value he will take the curves easier (he will go almost straight); if it is a large value it will take the curves suddenly (either it will oscillate on a straight line, or it will take the curve too tight and it will leave the track). Using "Ki" it helps the robot stop oscillating. The derivative term calculates the current error and the last error. When the robot suddenly hits a tight curve, this value will be high and will force the robot to take the required curve. At a Kd too small, this value might not take place and at a Kd too high, it can give errors to the whole program and the robot can oscillate, run very slowly or take very narrow curves that don't even exist. (I did many test runs and applied different values for Kp, Ki, Kd. After hundreds of test runs I concluded the correct values for each and I implemented the accurate values with the code. Therefore, I was able to develop the algorithm of the Robot to move smoothly in any condition)
 #### Switch Case Algorithm
 I designed this algorithm to dynamically change the speed of the robot according to each situation(In straight lines and In curved lines) I have you used a switch function to switch the speeds of the robot, using the PID algorithm I concluded accurate values corresponding to each speed limit and I stored the different speeds in a switch function under different cases. Therefore according to different situations in the platform, the robot can switch its speed dynamically (In straight lines the Robot moves fast and in curve lines the robot slowes down a bit smoothly using this algorithm) You can observe the Switch case function in the folder --> "Line_Follower_CS50.ino" under the function "void loop()".
 #### Hardware Components
 I have used the Arduino Nano as the micro-controller of the robot, the QTR-8 IR sensor array as the main sensor of the robot, 2 micro-metal gear motors as the main motors of the robot, TB6612FNG motor driver to control the motors, 6v voltage regulator to regulate the voltage from the battery and apply it to the motors of the robot, 5v voltage regulator to regulate the voltage from the battery and apply it to the micro-controller (Arduino Nano) and to the sensor array (QTR-8), and 2 3.7v batteries (connected in series connection method). These are the hardware components that I have used to develop the robot.
 #### IR sensor Array
 There are 8 small IR sensors in the array, using the sensor we can take the values of black surface and a white surface. Before each and every test run of the robot, the robot must be calibrated. So I developed a function that it can take 400 values by a for loop in both black and white surfaces by changing the position of the sensor in both surfaces and average the values to get the corresponding accurate value. "int error = position - 3500;" using this line of code, the robot is able to center it self in black line. You can observe the Calibration function in the folder --> sensor_control.ino under the function "void calibration()" and "void Auto_calibrtion()". You can observe the function that I programmed to follow the black line in the folder motion_control_ino -->  under the function "void propotional()".

 Shihan Embuldeniya.
